NAME
    accessors - create accessor methods in caller's package.

SYNOPSIS
      package Foo;
      use accessors qw( foo bar baz );

      my $obj = bless {}, 'Foo';

      # generates chaining accessors
      # that you can set like this:
      $obj->foo( 'hello ' )
          ->bar( 'world' )
          ->baz( "!\n" );

      # you get the values by passing no params:
      print $obj->foo, $obj->bar, $obj->baz;

DESCRIPTION
    The accessors pragma lets you create simple accessors at compile-time.

    This saves you from writing them by hand, which tends to result in
    *cut-n-paste* errors and a mess of duplicated code. It can also help you
    reduce the ammount of unwanted *direct-variable access* that may creep
    into your codebase when you're feeling lazy. accessors was designed with
    laziness in mind.

    Method-chaining accessors are generated by default. Note that you can
    still use accessors::chained directly for reasons of backwards
    compatibility.

    See accessors::rw for accessors that always return the current value if
    you don't like method chaining.

GENERATED METHODS
    accessors will generate methods that return the current object on set:

      sub foo {
          my $self = shift;
          if (@_) { $self->{-foo} = shift; return $self; }
          else    { return $self->{-foo}; }
      }

    This way they can be *chained* together.

  Why prepend the dash?
    The dash ("-") is prepended to the property name for a few reasons:

    *   interoperability with Error.

    *   to make it difficult to accidentally access the property directly
        ala:

          use accessors qw( foo );
          $obj->{foo};  # prevents this by mistake
          $obj->foo;    # when you probably meant this

        (this might sound woolly, but it's easy enough to do).

    *   syntactic sugar (this *is* woolly :).

    You shouldn't care too much about how the property is stored anyway - if
    you do, you're likely trying to do something special (and should really
    consider writing the accessors out long hand), or it's simply a matter
    of preference in which case you can use accessors::rw, or sub-class this
    module.

PERFORMANCE
    There is little-to-no performace hit when using generated accessors; in
    fact there is usually a performance gain.

    *   typically *10-30% faster* than hard-coded accessors (like the above
        example).

    *   typically *1-15% slower* than *optimized* accessors (less readable).

    *   typically a *small* performance hit at startup (accessors are
        created at compile-time).

    *   uses the same anonymous sub to reduce memory consumption (sometimes
        by 80%).

    See the benchmark tests included with this distribution for more
    details.

MOTIVATION
    The main difference between the accessors pragma and other accessor
    generators is simplicity.

    *   interface

        use accessors qw( ... ) is as easy as it gets.

    *   a pragma

        it fits in nicely with the base pragma:

          use base      qw( Some::Class );
          use accessors qw( foo bar baz );

        and accessors get created at compile-time.

    *   no bells and whistles

        The module is extensible instead.

SUB-CLASSING
    If you prefer a different style of accessor or you need to do something
    more complicated, there's nothing to stop you from sub-classing. It
    should be pretty easy. Look through accessors::classic, accessors::ro,
    and accessors::rw to see how it's done.

CAVEATS
    Classes using blessed scalarrefs, arrayrefs, etc. are not supported for
    sake of simplicity. Only hashrefs are supported.

  Class Accessors Are Not Supported
    If you are accidentally calling the accessor as a class method:

      my $object = 'Foo'; # an accident!
      print $object->bla, "\n"; # does not die!

    Then (as of v1.02) this will produce an error ala:

      Can't use string ("Foo") as a HASH ref while "strict refs" in use
      at lib/accessors.pm line 72.

THANKS
    Thanks to Michael G. Schwern for indirectly inspiring this module, and
    for his feedback & suggestions.

    Also to Paul Makepeace and David Wright for showing me faster accessors,
    to chocolateboy & others for their contributions, the CPAN Testers for
    their bug reports, and to James Duncan and people on London.pm for their
    feedback.

AUTHORS
    Steve Purkis <spurkis@cpan.org>

    Contributions from:

      chocolateboy
      Slaven ReziÄ‡

SOURCE
    <https://github.com/spurkis/Perl-accessors>

SEE ALSO
    accessors::classic, accessors::chained

    Similar and related modules:

    base, fields, Class::Accessor, Moose, Class::Struct, Class::Methodmaker,
    Class::Generate, Class::Class, Class::Tangram, Object::Tiny

